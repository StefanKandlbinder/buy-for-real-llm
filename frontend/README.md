# Buy For Real - Frontend

This is the frontend for the "Buy For Real" application. It's a [Next.js](https://nextjs.org/) project using a [tRPC](https://trpc.io/) backend, a [PostgreSQL](https://www.postgresql.org/) database with [Drizzle ORM](https://orm.drizzle.team/), and [Clerk](https://clerk.com/) for authentication.

## Tech Stack

- **Framework:** [Next.js](https://nextjs.org/) (with App Router & Turbopack)
- **API:** [tRPC](https://trpc.io/) & Next.js Server Actions
- **Database:** [PostgreSQL](https://www.postgresql.org/) (via [Neon](https://neon.tech/))
- **ORM:** [Drizzle ORM](https://orm.drizzle.team/)
- **Authentication:** [Clerk](https://clerk.com/)
- **Styling:** [Tailwind CSS](https://tailwindcss.com/)
- **UI Components:** [Shadcn UI](https://ui.shadcn.com/)
- **Schema Validation:** [Zod](https://zod.dev/)
- **State Management:** [React Query](https://tanstack.com/query/v5)

## Project Architecture

This project follows a strict convention of using **tRPC for all database-related API communication**. Standard Next.js API routes (`/app/api/route.ts`) are disallowed to maintain a consistent and type-safe API layer.

For operations that require `FormData`, such as file uploads, **Next.js Server Actions** are used. These actions handle the multipart data and then call the tRPC API internally using the server-side caller for database operations, thus respecting the architectural rules.

React Compiler is enabled for the entire app via Next.js config and React 19. No manual `memo`/`useMemo`/`useCallback` is necessary unless profiling shows a need.

## Project Structure

- `src/app`: Route files and layouts (kept thin; delegates to features).
- `src/actions`: Next.js Server Actions (form-data upload, etc.).
- `src/features`: Domain modules (e.g., `products`, `advertisements`, `groups`, `media`). Each feature has `components/`, `hooks/`, and optional `api/`, `validation/`, `lib/`.
- `src/shared`: App-wide building blocks used across features.
  - `src/shared/components`: e.g., `AppSidebar`, `AuthModal`, `ConfirmDialog`, `Error/*`, `ThemeProvider`.
  - `src/shared/hooks`: e.g., `use-mobile`.
- `src/components/ui`: shadcn UI primitives.
- `src/lib`: Shared utilities (e.g., `config`, `query-client`, `roles`, `utils`).
- `src/db`: Drizzle schema and database connection.
- `src/trpc`: tRPC server and client implementation.
- `drizzle`: Database migration files generated by Drizzle Kit.

## Providers & Core Utilities

### TRPC + React Query Provider

The app uses a single provider that instantiates a shared Query Client and tRPC client with auth headers.

```tsx
// src/trpc/client/trpc-provider.tsx
"use client";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink, loggerLink } from "@trpc/client";
import superjson from "superjson";
import { TRPCProvider } from "./client";
import { getUrl } from "./utils";
import { AppRouter } from "@/trpc/server";
import { useAuth } from "@clerk/nextjs";
import { createQueryClient } from "@/lib/query-client";

let browserQueryClient: QueryClient | undefined;
function getQueryClient() {
  if (typeof window === "undefined") return createQueryClient();
  if (!browserQueryClient) browserQueryClient = createQueryClient();
  return browserQueryClient;
}

export function TRPCReactProvider({
  children,
  headerEntries,
}: {
  children: React.ReactNode;
  headerEntries: Array<[string, string]>;
}) {
  const queryClient = getQueryClient();
  const { getToken } = useAuth();
  const trpcClient = createTRPCClient<AppRouter>({
    links: [
      loggerLink({
        enabled: (opts) =>
          process.env.NODE_ENV === "development" ||
          (opts.direction === "down" && opts.result instanceof Error),
      }),
      httpBatchLink({
        url: getUrl(),
        transformer: superjson,
        async headers() {
          const heads = new Map(headerEntries);
          heads.set("x-trpc-source", "react");
          const token = await getToken();
          if (token) heads.set("authorization", `Bearer ${token}`);
          return Object.fromEntries(heads);
        },
      }),
    ],
  });

  return (
    <QueryClientProvider client={queryClient}>
      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
        {children}
      </TRPCProvider>
    </QueryClientProvider>
  );
}
```

### Centralized Query Client Defaults

```ts
// src/lib/query-client.ts
import { QueryClient } from "@tanstack/react-query";

export function createQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 1000 * 60 * 5,
        gcTime: 1000 * 60 * 10,
        retry: (failureCount, error: any) => {
          const status = error?.status as number | undefined;
          if (
            typeof status === "number" &&
            status >= 400 &&
            status < 500 &&
            status !== 408
          ) {
            return false;
          }
          return failureCount < 3;
        },
        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      },
      mutations: {
        retry: false,
        onError: (error) => console.error("Mutation error:", error),
      },
    },
  });
}
```

### Centralized Invalidation Utilities

```ts
// src/trpc/client/utils.ts
import { QueryClient } from "@tanstack/react-query";

export function createInvalidators(
  queryClient: QueryClient,
  trpc: ReturnType<typeof import("@/trpc/client/client").useTRPC>
) {
  return {
    productsCluster: async () => {
      await Promise.all([
        queryClient.invalidateQueries({
          queryKey: trpc.products.getAllProducts.queryKey(),
        }),
        queryClient.invalidateQueries({
          queryKey: trpc.groups.getGroupsWithProducts.queryKey(),
        }),
        queryClient.invalidateQueries({
          queryKey: trpc.groups.getNestedGroups.queryKey(),
        }),
      ]);
    },
    advertisementsCluster: async () => {
      await Promise.all([
        queryClient.invalidateQueries({
          queryKey: trpc.advertisements.getAllAdvertisements.queryKey(),
        }),
        queryClient.invalidateQueries({
          queryKey: trpc.groups.getGroupsWithAdvertisements.queryKey(),
        }),
        queryClient.invalidateQueries({
          queryKey: trpc.groups.getNestedGroups.queryKey(),
        }),
      ]);
    },
    groupsCluster: async () => {
      await Promise.all([
        queryClient.invalidateQueries({
          queryKey: trpc.groups.getNestedGroups.queryKey(),
        }),
        queryClient.invalidateQueries({
          queryKey: trpc.groups.getGroupsWithProducts.queryKey(),
        }),
        queryClient.invalidateQueries({
          queryKey: trpc.groups.getGroupsWithAdvertisements.queryKey(),
        }),
      ]);
    },
  };
}
```

## Error Handling System

This application features a comprehensive error handling system that provides meaningful user feedback through toast notifications while maintaining a great user experience even when things go wrong.

### Components

#### 1. Global Error Page (`src/app/error.tsx`)

- **Purpose**: Catches server-side and Next.js routing errors at the application level
- **Features**:
  - Automatically shows toast notifications with user-friendly error messages
  - Provides retry and navigation options
  - Handles common error types (UNAUTHORIZED, NOT_FOUND, network errors, etc.)
  - Includes error IDs for debugging in production

#### 2. React ErrorBoundary (`src/shared/components/Error/ErrorBoundary.tsx`)

- **Purpose**: Catches JavaScript errors in React components during rendering
- **Features**:
  - Automatic toast notifications for component errors
  - Fallback UI with recovery options
  - Development-friendly error details
  - Customizable fallback components
  - `useErrorHandler` hook for manual error reporting

#### 3. Error Provider (`src/shared/components/Error/ErrorProvider.tsx`)

- **Purpose**: Provides consistent error reporting context throughout the application
- **Features**:
  - `reportError()`, `reportWarning()`, and `reportInfo()` functions
  - Smart error message transformation for better UX
  - Context-aware error descriptions
  - `useAsyncErrorHandler` hook for async operations

#### 4. Demo Component (`src/shared/components/Error/ErrorBoundaryDemo.tsx`)

- **Purpose**: Interactive demonstration and testing of error handling capabilities
- **Features**: Test different error scenarios and see usage examples

### Integration with Toast System

The error handling system seamlessly integrates with the existing [Sonner](https://sonner.emilkowal.ski/) toast system:

- **Consistent UI**: All error notifications use the same toast component
- **Theme-Aware**: Toasts respect the application's dark/light theme
- **Action Buttons**: Error toasts include retry, refresh, or navigation actions
- **Duration Control**: Different error types have appropriate display durations

### Usage Examples

#### Basic Error Reporting

```typescript
import { useErrorReporting } from "@/shared/components/Error/ErrorProvider";

function MyComponent() {
  const { reportError } = useErrorReporting();

  const handleAsyncOperation = async () => {
    try {
      await someApiCall();
    } catch (error) {
      reportError(error as Error, "Failed to load data");
    }
  };
}
```

#### Component Error Boundaries

```typescript
import ErrorBoundary from "@/shared/components/Error/ErrorBoundary";

function MyPage() {
  return (
    <ErrorBoundary>
      <ComponentThatMightError />
    </ErrorBoundary>
  );
}
```

#### Manual Error Handling

```typescript
import { useErrorHandler } from "@/shared/components/Error/ErrorBoundary";

function MyComponent() {
  const errorHandler = useErrorHandler();

  const handleError = () => {
    const error = new Error("Custom error message");
    errorHandler(error);
  };
}
```

### Error Message Intelligence

The system automatically transforms technical errors into user-friendly messages:

- **Network Errors**: "Network error. Please check your internet connection."
- **Authentication**: "You need to sign in to continue."
- **Authorization**: "You don't have permission to perform this action."
- **Validation**: "Please check your input and try again."
- **File Upload**: "File is too large. Please choose a smaller file."
- **Generic Fallback**: Sanitized versions of original error messages

### Benefits

- **Enhanced UX**: Users see helpful error messages instead of technical jargon
- **Error Recovery**: Built-in retry and navigation options
- **Developer Experience**: Detailed error information in development mode
- **Production Safety**: Sanitized error messages in production
- **Consistent Design**: All errors follow the same visual and interaction patterns
- **Contextual Information**: Errors include relevant context about what operation failed

## Getting Started

### Prerequisites

- Node.js
- pnpm
- A PostgreSQL database (e.g., from [Neon](https://neon.tech/))

### Installation & Setup

1.  **Install dependencies:**

    ```bash
    pnpm install
    ```

2.  **Set up environment variables:**
    Create a `.env.local` file by copying the `.env.example` file. Add the necessary environment variables, including your `DATABASE_URL` and credentials for Clerk and Pinata.

3.  **Run database migrations:**
    ```bash
    pnpm db:generate
    pnpm db:migrate
    ```

### Running the Development Server

To start the development server, run:

```bash
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Available Scripts

- `pnpm dev`: Starts the development server with Turbopack.
- `pnpm build`: Creates a production build of the application.
- `pnpm start`: Starts the production server.
- `pnpm lint`: Lints the codebase using Next.js's ESLint configuration.
- `pnpm db:generate`: Generates a new database migration based on schema changes.
- `pnpm db:migrate`: Applies pending database migrations.
- `pnpm db:studio`: Opens the Drizzle Studio to browse your database.

## Deployment on Vercel

This project is configured for continuous deployment on [Vercel](https://vercel.com/).

### CI/CD Pipeline

A GitHub Actions workflow is set up in `.github/workflows/vercel.yml` to automate the deployment process. The pipeline triggers on any push or pull request to the `main` branch and performs the following steps:

1.  **Checkout & Setup:** Checks out the code and sets up the Node.js environment.
2.  **Install Dependencies:** Installs project dependencies using `pnpm`.
3.  **Lint:** Runs the linter to ensure code quality.
4.  **Deploy:** Builds and deploys the project to Vercel. A preview deployment is created for pull requests, and a production deployment is made for pushes to `main`.

### Environment Variables

For the deployment to succeed, you must configure the following secrets in your GitHub repository settings (`Settings > Secrets and variables > Actions`):

- `VERCEL_ORG_ID`: Your Vercel organization ID.
- `VERCEL_PROJECT_ID`: The ID of the corresponding project on Vercel.
- `VERCEL_TOKEN`: A Vercel access token with deployment permissions.
- `DATABASE_URL`: The connection string for your production database.
- `PINATA_API_KEY`: Your Pinata API key.
- `PINATA_API_SECRET`: Your Pinata API secret.
- `PINATA_JWT`: Your Pinata JWT.
- `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`: Your Clerk publishable key.
- `CLERK_SECRET_KEY`: Your Clerk secret key.
- `NEXT_PUBLIC_BODY_SIZE_LIMIT_MB`: Body size limit in MB for server actions (default 50).
- `NEXT_PUBLIC_MAX_FILE_SIZE_KB`: Client/server-upload size checks (e.g. 51200 for 50MB).

## Next.js Configuration Notes

- React Compiler is enabled via `experimental.reactCompiler: true`. It is active in builds (see build logs).
- Image remote patterns use the object format with `protocol/hostname/pathname`. Update the hostname if your Pinata gateway changes.
